<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[那一刻，恍然如梦。对，那就是梦！]]></title>
    <url>%2F2017%2F06%2F28%2FA-lovely-dream%2F</url>
    <content type="text"><![CDATA[那一刻，恍然如梦。对，那就是梦！Lovely❤ 连续几天没更新博客，说好的好习惯就这样终结了？ 不这只是开始 找个小借口吧~这几天老是重复这个。 像是在反思过去一样，纳些年失去的，历历在目。没想到在梦里已没有权利。也不知道这意味着什么？]]></content>
      <categories>
        <category>博客日志</category>
      </categories>
      <tags>
        <tag>博客日志</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F06%2F25%2Flog05%2F</url>
    <content type="text"><![CDATA[title: [转载]2017百大框架排行date: 2017-06-25 23:21:46tags: 框架categories: Android]]></content>
  </entry>
  <entry>
    <title><![CDATA[Socket详解]]></title>
    <url>%2F2017%2F06%2F24%2FSocketExplain%2F</url>
    <content type="text"><![CDATA[年轻时候，如果爱，别说永远，说珍惜。❤ 这是一份很详细的Socket使用攻略 原文地址 前言 Socket的使用在 Android网络编程中非常重要 今天我将带大家全面了解 Socket 及 其使用方法 目录 目录 1.网络基础1.1 计算机网络分层计算机网络分为五层：物理层、数据链路层、网络层、运输层、应用层 计算机网络 其中： 网络层：负责根据IP找到目的地址的主机 运输层：通过端口把数据传到目的主机的目的进程，来实现进程与进程之间的通信 1.2 端口号（PORT）端口号规定为16位，即允许一个IP主机有2的16次方65535个不同的端口。其中： 0~1023：分配给系统的端口号 ​ 我们不可以乱用 1024~49151：登记端口号，主要是让第三方应用使用 ​ 但是必须在IANA（互联网数字分配机构）按照规定手续登记， 49152~65535：短暂端口号，是留给客户进程选择暂时使用，一个进程使用完就可以供其他进程使用。 在Socket使用时，可以用1024~65535的端口号 1.3 C/S结构 定义：即客户端/服务器结构，是软件系统体系结构 作用：充分利用两端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通讯开销。 ​ Socket正是使用这种结构建立连接的，一个套接字接客户端，一个套接字接服务器。 如图： Socket架构 可以看出，Socket的使用可以基于TCP或者UDP协议。 1.4 TCP协议 定义：Transmission Control Protocol，即传输控制协议，是一种传输层通信协议 ​ 基于TCP的应用层协议有FTP、Telnet、SMTP、HTTP、POP3与DNS。 特点：面向连接、面向字节流、全双工通信、可靠 面向连接：指的是要使用TCP传输数据，必须先建立TCP连接，传输完成后释放连接，就像打电话一样必须先拨号建立一条连接，打完后挂机释放连接。 全双工通信：即一旦建立了TCP连接，通信双方可以在任何时候都能发送数据。 可靠的：指的是通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。 面向字节流：流，指的是流入到进程或从进程流出的字符序列。简单来说，虽然有时候要传输的数据流太大，TCP报文长度有限制，不能一次传输完，要把它分为好几个数据块，但是由于可靠性保证，接收方可以按顺序接收数据块然后重新组成分块之前的数据流，所以TCP看起来就像直接互相传输字节流一样，面向字节流。 TCP建立连接 ​ 必须进行 三次握手 ：若A要与B进行连接，则必须 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认。即A发送信息给B 第二次握手：服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认。即B收到连接信息后向A返回确认信息 第三次握手：客户端收到服务器的（SYN+ACK）报文段，并向服务器发送ACK报文段。即A收到确认信息后再次向B返回确认连接信息 ​ 此时，A告诉自己上层连接建立；B收到连接信息后告诉上层连接建立。 TCP三次握手 这样就完成TCP三次握手 = 一条TCP连接建立完成 = 可以开始发送数据 三次握手期间任何一次未收到对面回复都要重发。 最后一个确认报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态。 为什么TCP建立连接需要三次握手？答：防止服务器端因为接收了早已失效的连接请求报文从而一直等待客户端请求，从而浪费资源 “已失效的连接请求报文段”的产生在这样一种情况下：Client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。 这是一个早已失效的报文段。但Server收到此失效的连接请求报文段后，就误认为是Client再次发出的一个新的连接请求。 于是就向Client发出确认报文段，同意建立连接。 假设不采用“三次握手”：只要Server发出确认，新的连接就建立了。 由于现在Client并没有发出建立连接的请求，因此不会向Server发送数据。 但Server却以为新的运输连接已经建立，并一直等待Client发来数据。&gt;- 这样，Server的资源就白白浪费掉了。 采用“三次握手”的办法可以防止上述现象发生： Client不会向Server的确认发出确认 Server由于收不到确认，就知道Client并没有要求建立连接 所以Server不会等待Client发送数据，资源就没有被浪费 TCP释放连接 ​ TCP释放连接需要 四次挥手 过程，现在假设A主动释放连接：（数据传输结束后，通信的双方都可释放连接） 第一次挥手：A发送释放信息到B；（发出去之后，A-&gt;B发送数据这条路径就断了） 第二次挥手：B收到A的释放信息之后，回复确认释放的信息：我同意你的释放连接请求 第三次挥手：B发送“请求释放连接“信息给A 第四次挥手：A收到B发送的信息后向B发送确认释放信息：我同意你的释放连接请求 ​ B收到确认信息后就会正式关闭连接； A等待2MSL后依然没有收到回复，则证明B端已正常关闭，于是A关闭连接 TCp四次握手 为什么TCP释放连接需要四次挥手？为了保证双方都能通知对方“需要释放连接”，即在释放连接后都无法接收或发送消息给对方 需要明确的是：TCP是全双工模式，这意味着是双向都可以发送、接收的 释放连接的定义是：双方都无法接收或发送消息给对方，是双向的 当主机1发出“释放连接请求”（FIN报文段）时，只是表示主机1已经没有数据要发送 / 数据已经全部发送完毕； ​ 但是，这个时候主机1还是可以接受来自主机2的数据。 当主机2返回“确认释放连接”信息（ACK报文段）时，表示它已经知道主机1没有数据发送了 ​ 但此时主机2还是可以发送数据给主机1 当主机2也发送了FIN报文段时，即告诉主机1我也没有数据要发送了 ​ 此时，主机1和2已经无法进行通信：主机1无法发送数据给主机2，主机2也无法发送数据给主机1，此时，TCP的连接才算释放 1.5 UDP协议 定义：User Datagram Protocol，即用户数据报协议，是一种传输层通信协议。 ​ 基于UDP的应用层协议有TFTP、SNMP与DNS。 特点：无连接的、不可靠的、面向报文、没有拥塞控制 无连接的：和TCP要建立连接不同，UDP传输数据不需要建立连接，就像写信，在信封写上收信人名称、地址就可以交给邮局发送了，至于能不能送到，就要看邮局的送信能力和送信过程的困难程度了。 不可靠的：因为UDP发出去的数据包发出去就不管了，不管它会不会到达，所以很可能会出现丢包现象，使传输的数据出错。 面向报文：数据报文，就相当于一个数据包，应用层交给UDP多大的数据包，UDP就照样发送，不会像TCP那样拆分。 没有拥塞控制：拥塞，是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象，就像交通堵塞一样。TCP建立连接后如果发送的数据因为信道质量的原因不能到达目的地，它会不断重发，有可能导致越来越塞，所以需要一个复杂的原理来控制拥塞。而UDP就没有这个烦恼，发出去就不管了。 应用场景 很多的实时应用（如IP电话、实时视频会议、某些多人同时在线游戏等）要求源主机以很定的速率发送数据，并且允许在网络发生拥塞时候丢失一些数据，但是要求不能有太大的延时，UDP就刚好适合这种要求。所以说，只有不适合的技术，没有真正没用的技术。 1.6 HTTP协议详情请看我写的另外一篇文章你需要了解的HTTP知识都在这里了！ 2. Socket定义 即套接字， 是一个对 TCP / IP协议进行封装 的编程调用接口（API） ​ 即通过Socket，我们才能在Andorid平台上通过 TCP/IP协议进行开发 Socket不是一种协议，而是一个编程调用接口（API），属于传输层（主要解决数据如何在网络中传输） 成对出现，一对套接字： 1Socket =&#123;(IP地址1:PORT端口号)，(IP地址2:PORT端口号)&#125; 3. 原理Socket的使用类型主要有两种： 流套接字（streamsocket） ：基于 TCP协议，采用 流的方式 提供可靠的字节流服务 数据报套接字(datagramsocket)：基于 UDP协议，采用 数据报文 提供数据打包发送的服务 具体原理图如下： 原理图 4. Socket 与 Http 对比 Socket属于传输层，因为 TCP / IP协议属于传输层，解决的是数据如何在网络中传输的问题 HTTP协议 属于 应用层，解决的是如何包装数据 由于二者不属于同一层面，所以本来是没有可比性的。但随着发展，默认的Http里封装了下面几层的使用，所以才会出现Socket &amp; HTTP协议的对比：（主要是工作方式的不同）： 1Http ：采用 请求—响应 方式。 ​ 即建立网络连接后，当 客户端 向 服务器 发送请求后，服务器端才能向客户端返回数据。 可理解为：是客户端有需要才进行通信 1Socket ：采用 服务器主动发送数据 的方式 ​ 即建立网络连接后，服务器可主动发送消息给客户端，而不需要由客户端向服务器发送请求 可理解为：是服务器端有需要才进行通信 5. 使用步骤 Socket可基于TCP或者UDP协议，但TCP更加常用 所以下面的使用步骤 &amp; 实例的Socket将基于TCP协议 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 步骤1：创建客户端 &amp; 服务器的连接 // 创建Socket对象 &amp; 指定服务端的IP及端口号 Socket socket = new Socket(&quot;192.168.1.32&quot;, 1989); // 判断客户端和服务器是否连接成功 socket.isConnected());// 步骤2：客户端 &amp; 服务器 通信// 通信包括：客户端 接收服务器的数据 &amp; 发送数据 到 服务器 &lt;-- 操作1：接收服务器的数据 --&gt; // 步骤1：创建输入流对象InputStream InputStream is = socket.getInputStream() // 步骤2：创建输入流读取器对象 并传入输入流对象 // 该对象作用：获取服务器返回的数据 InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); // 步骤3：通过输入流读取器对象 接收服务器发送过来的数据 br.readLine()； &lt;-- 操作2：发送数据 到 服务器 --&gt; // 步骤1：从Socket 获得输出流对象OutputStream // 该对象作用：发送数据 OutputStream outputStream = socket.getOutputStream(); // 步骤2：写入需要发送的数据到输出流对象中 outputStream.write（（&quot;Carson_Ho&quot;+&quot;\n&quot;）.getBytes(&quot;utf-8&quot;)）； // 特别注意：数据的结尾加上换行符才可让服务器端的readline()停止阻塞 // 步骤3：发送数据到服务端 outputStream.flush(); // 步骤3：断开客户端 &amp; 服务器 连接 os.close(); // 断开 客户端发送到服务器 的连接，即关闭输出流对象OutputStream br.close(); // 断开 服务器发送到客户端 的连接，即关闭输入流读取器对象BufferedReader socket.close(); // 最终关闭整个Socket连接 6. 具体实例 实例 Demo 代码包括：客户端 &amp; 服务器 本文着重讲解客户端，服务器仅采用最简单的写法进行展示 6.1 客户端 实现步骤1：加入网络权限 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 步骤2：主布局界面设置 包括创建Socket连接、客户端 &amp; 服务器通信的按钮 123456789101112131415161718192021222324252627282930313233&lt;Button android:id=&quot;@+id/connect&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;connect&quot; /&gt;&lt;Button android:id=&quot;@+id/disconnect&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;disconnect&quot; /&gt;&lt;TextView android:id=&quot;@+id/receive_message&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;Button android:id=&quot;@+id/Receive&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Receive from message&quot; /&gt;&lt;EditText android:id=&quot;@+id/edit&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;Button android:id=&quot;@+id/send&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;send&quot;/&gt; 步骤3：创建Socket连接、客户端 &amp; 服务器通信 具体请看注释 MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239package scut.carson_ho.socket_carson;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.TextView;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.Socket;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class MainActivity extends AppCompatActivity &#123; /** * 主 变量 */ // 主线程Handler // 用于将从服务器获取的消息显示出来 private Handler mMainHandler; // Socket变量 private Socket socket; // 线程池 // 为了方便展示,此处直接采用线程池进行线程管理,而没有一个个开线程 private ExecutorService mThreadPool; /** * 接收服务器消息 变量 */ // 输入流对象 InputStream is; // 输入流读取器对象 InputStreamReader isr ; BufferedReader br ; // 接收服务器发送过来的消息 String response; /** * 发送消息到服务器 变量 */ // 输出流对象 OutputStream outputStream; /** * 按钮 变量 */ // 连接 断开连接 发送数据到服务器 的按钮变量 private Button btnConnect, btnDisconnect, btnSend; // 显示接收服务器消息 按钮 private TextView Receive,receive_message; // 输入需要发送的消息 输入框 private EditText mEdit; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** * 初始化操作 */ // 初始化所有按钮 btnConnect = (Button) findViewById(R.id.connect); btnDisconnect = (Button) findViewById(R.id.disconnect); btnSend = (Button) findViewById(R.id.send); mEdit = (EditText) findViewById(R.id.edit); receive_message = (TextView) findViewById(R.id.receive_message); Receive = (Button) findViewById(R.id.Receive); // 初始化线程池 mThreadPool = Executors.newCachedThreadPool(); // 实例化主线程,用于更新接收过来的消息 mMainHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 0: receive_message.setText(response); break; &#125; &#125; &#125;; /** * 创建客户端 &amp; 服务器的连接 */ btnConnect.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 利用线程池直接开启一个线程 &amp; 执行该线程 mThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; // 创建Socket对象 &amp; 指定服务端的IP 及 端口号 socket = new Socket(&quot;192.168.1.172&quot;, 8989); // 判断客户端和服务器是否连接成功 System.out.println(socket.isConnected()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125;); /** * 接收 服务器消息 */ Receive.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 利用线程池直接开启一个线程 &amp; 执行该线程 mThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; // 步骤1：创建输入流对象InputStream is = socket.getInputStream(); // 步骤2：创建输入流读取器对象 并传入输入流对象 // 该对象作用：获取服务器返回的数据 isr = new InputStreamReader(is); br = new BufferedReader(isr); // 步骤3：通过输入流读取器对象 接收服务器发送过来的数据 response = br.readLine(); // 步骤4:通知主线程,将接收的消息显示到界面 Message msg = Message.obtain(); msg.what = 0; mMainHandler.sendMessage(msg); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125;); /** * 发送消息 给 服务器 */ btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 利用线程池直接开启一个线程 &amp; 执行该线程 mThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; // 步骤1：从Socket 获得输出流对象OutputStream // 该对象作用：发送数据 outputStream = socket.getOutputStream(); // 步骤2：写入需要发送的数据到输出流对象中 outputStream.write((mEdit.getText().toString()+&quot;\n&quot;).getBytes(&quot;utf-8&quot;)); // 特别注意：数据的结尾加上换行符才可让服务器端的readline()停止阻塞 // 步骤3：发送数据到服务端 outputStream.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125;); /** * 断开客户端 &amp; 服务器的连接 */ btnDisconnect.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; // 断开 客户端发送到服务器 的连接，即关闭输出流对象OutputStream outputStream.close(); // 断开 服务器发送到客户端 的连接，即关闭输入流读取器对象BufferedReader br.close(); // 最终关闭整个Socket连接 socket.close(); // 判断客户端和服务器是否已经断开连接 System.out.println(socket.isConnected()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 6.2 服务器 实现 因本文主要讲解客户端，所以服务器仅仅是为了配合客户端展示； 为了简化服务器使用，此处采用 1Mina 框架 ​ 服务器代码请在eclipse平台运行 按照我的步骤一步步实现就可以无脑运行了 步骤1：导入Mina包 请直接移步到百度网盘：下载链接（密码: q73e） 示意图 步骤2：创建服务器线程 TestHandler.java 123456789101112131415161718192021222324252627282930313233343536package mina;// 导入包public class TestHandler extends IoHandlerAdapter &#123; @Override public void exceptionCaught(IoSession session, Throwable cause) throws Exception &#123; System.out.println(&quot;exceptionCaught: &quot; + cause); &#125; @Override public void messageReceived(IoSession session, Object message) throws Exception &#123; System.out.println(&quot;recieve : &quot; + (String) message); session.write(&quot;hello I am server&quot;); &#125; @Override public void messageSent(IoSession session, Object message) throws Exception &#123; &#125; @Override public void sessionClosed(IoSession session) throws Exception &#123; System.out.println(&quot;sessionClosed&quot;); &#125; @Override public void sessionOpened(IoSession session) throws Exception &#123; System.out.println(&quot;sessionOpen&quot;); &#125; @Override public void sessionIdle(IoSession session, IdleStatus status) throws Exception &#123; &#125;&#125; 步骤3：创建服务器主代码 TestHandler.java 1234567891011121314151617181920212223package mina;import java.io.IOException;import java.net.InetSocketAddress;import org.apache.mina.filter.codec.ProtocolCodecFilter;import org.apache.mina.filter.codec.textline.TextLineCodecFactory;import org.apache.mina.transport.socket.nio.NioSocketAcceptor;public class TestServer &#123; public static void main(String[] args) &#123; NioSocketAcceptor acceptor = null; try &#123; acceptor = new NioSocketAcceptor(); acceptor.setHandler(new TestHandler()); acceptor.getFilterChain().addLast(&quot;mFilter&quot;, new ProtocolCodecFilter(new TextLineCodecFactory())); acceptor.setReuseAddress(true); acceptor.bind(new InetSocketAddress(8989)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 至此，客户端 &amp; 服务器的代码均实现完毕。 6.3 测试结果 点击 Connect按钮： 连接成功 示意图 输入发送的消息，点击 Send 按钮发送 示意图 服务器接收到客户端发送的消息 示意图 点击 Receive From Message按钮，客户端 读取 服务器返回的消息 示意图 点击 DisConnect按钮，断开 客户端 &amp; 服务器的连接 客户端示意图 服务器示意图 6.4 源码地址Carson_Ho的Github地址：Socket具体实例]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin上手]]></title>
    <url>%2F2017%2F06%2F23%2Flog04%2F</url>
    <content type="text"><![CDATA[命运·梦想·抉择 —我并不想放弃不过多一条路不是不好呵呵❤ 快速上手kotlin 今年的谷歌IO大会上谷歌正式将Kotlin定为谷歌的官方语言,并且AndroidStudio已经对Kotlin完全支持.今天就分享一篇文章来了解一下Kotlin 用 Kotlin 怎么写” 的问题，作为有经验的程序员，我们已经掌握了一门或者多门语言，那么学 Kotlin 的时候就经常会有类似 “ ‘再见’用日语怎么说？”、“ ‘你好’ 用西班牙语怎么说？” 的问题，所以我决定把一些常用的语法对照列举出来，如果大家熟悉 Java，那么快速上手 Kotlin 会变得非常地容易。 这篇文章主要是写给需要快速上手 Kotlin 的 Java 程序员看的，这时候他们关注的是如何 Kotlin 写出类似某些 Java 的写法，所以本文基本不涉及 Kotlin 的高级特性。 1. 如何定义变量 Java 定义变量的写法： 1String string = &quot;Hello&quot;; 基本等价的 Kotlin 定义变量的写法： 1var string: String = &quot;Hello&quot; Java 定义 final 变量的写法： 1final String string = &quot;Hello&quot;; 注意到前面的是一个编译期常量，Kotlin 当中应该这么写： 1const val string: String = &quot;Hello&quot; 同样是 final 变量，Java 这么写： 1final String string = getString(); 注意到，这个不是编译期常量，Kotlin 这么写： 1val string: String = getString() 另外， Kotlin 有类型推导的特性，因此上述变量定义基本上都可以省略掉类型 String。 2. 如何定义函数Java 当中如何定义函数，也就是方法，需要定义到一个类当中： 123public boolean testString(String name)&#123; ...&#125; 等价的 Kotlin 写法： 123fun testString(name: String): Boolean &#123; ...&#125; 注意到返回值的位置放到了参数之后。 3. 如何定义静态变量、方法Java 的静态方法或者变量只需要加一个 static 即可： 123456789public class Singleton&#123; private static Singleton instance = ...; public static Singleton getInstance()&#123; ... return instance; &#125;&#125; 用 Kotlin 直译过来就是： 1234567891011class KotlinSingleton&#123; companion object&#123; private val kotlinSingleton = KotlinSingleton() @JvmStatic fun getInstance() = kotlinSingleton &#125;&#125; 注意 getInstance 的写法。 JvmStatic 这个注解会将 getInstance 这个方法编译成与 Java 的静态方法一样的签名，如果不加这个注解，Java 当中无法像调用 Java 静态方法那样调用这个方法。 另外，对于静态方法、变量的场景，在 Kotlin 当中建议使用包级函数。 4. 如何定义数组Java 的数组非常简单，当然也有些抽象，毕竟是编译期生成的类： 123String[] names = new String[]&#123;&quot;Kyo&quot;, &quot;Ryu&quot;, &quot;Iory&quot;&#125;; String[] emptyStrings = new String[10]; Kotlin 的数组其实更真实一些，看上去更让人容易理解： 123val names: Array&lt;String&gt; = arrayOf(&quot;Kyo&quot;, &quot;Ryu&quot;, &quot;Iory&quot;) val emptyStrings: Array&lt;String?&gt; = arrayOfNulls(10) 注意到，ArrayT 即数组元素的类型。另外，String? 表示可以为 null 的 String 类型。 数组的使用基本一致。需要注意的是，为了避免装箱和拆箱的开销，Kotlin 对基本类型包括 Int、Short、Byte、Long、Float、Double、Char 等基本类型提供了定制版数组类型，写法为 XArray，例如 Int 的定制版数组为 IntArray，如果我们要定义一个整型数组，写法如下： 1val ints = intArrayOf(1, 3, 5) 5. 如何写变长参数Java 的变长参数写法如下： 123void hello(String... names)&#123; ...&#125; Kotlin 的变长参数写法如下： 123fun hello(vararg names: String)&#123; &#125; 6. 如何写三元运算符Java 可以写三元运算符： 1int code = isSuccessfully? 200: 400; 很多人抱怨 Kotlin 为什么没有这个运算符。。。据说是因为 Kotlin 当中 : 使用的场景比 Java 复杂得多，因此如果加上这个三元运算符的话，会给语法解析器带来较多的麻烦，Scala 也是类似的情况。那么这中情况下，我们用 Kotlin 该怎么写呢？ 1int code = if(isSuccessfully) 200 else 400 注意到，if else 这样的语句也是表达式，这一点与 Java 不同。 7. 如何写 main 函数Java 的写法只有一种： 123456class Main&#123; public static void main(String... args)&#123; ... &#125;&#125; 注意到参数可以是变长参数或者数组，这二者都可。 对应 Kotlin，main 函数的写法如下： 1234567891011class KotlinMain&#123; companion object&#123; @JvmStatic fun main(args: Array&lt;String&gt;) &#123; &#125; &#125;&#125; Kotlin 可以有包级函数，因此我们并不需要声明一个类来包装 main 函数： 123fun main(args: Array&lt;String&gt;)&#123; ...&#125; 8. 如何实例化类Java 和 C++ 这样的语言，在构造对象的时候经常需要用到 new 这个关键字，比如： 1Date date = new Date(); Kotlin 构造对象时，不需要 new 这个关键字，所以上述写法等价于： 1val date = Date() 9. 如何写 Getter 和 Setter 方法Java 的 Getter 和 Setter 是一种约定俗称，而不是语法特性，所以定义起来相对自由： 12345678910111213public class GetterAndSetter&#123; private int x = 0; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125;&#125; Kotlin 是有属性的： 12345678class KotlinGetterAndSetter&#123; var x: Int = 0 set(value) &#123; field = value &#125; get() = field&#125; 注意看到，我们为 x 显式定义了 getter 和 setter，field 是 x 背后真正的变量，所以 setter 当中其实就是为 field 赋值，而 getter 则是返回 field。如果你想要对 x 的访问做控制，那么你就可以通过自定义 getter 和 setter 来实现了： 1234567891011121314151617181920212223242526272829class KotlinGetterAndSetter&#123; var x: Int = 0 set(value) &#123; val date = Calendar.getInstance().apply &#123; set(2017, 2, 18) &#125; if(System.currentTimeMillis() &lt; date.timeInMillis)&#123; println(&quot;Cannot be set before 2017.3.18&quot;) &#125;else&#123; field = value &#125; &#125; get()&#123; println(&quot;Get field x: $field&quot;) return field &#125; &#125; 10. 如何延迟初始化成员变量Java 定义的类成员变量如果不初始化，那么基本类型被初始化为其默认值，比如 int 初始化为 0，boolean 初始化为 false，非基本类型的成员则会被初始化为 null。 12345public class Hello&#123; private String name; &#125; 类似的代码在 Kotlin 当中直译为： 12345class Hello&#123; private var name: String? = null &#125; 使用了可空类型，副作用就是后面每次你想要用 name 的时候，都需要判断其是否为 null。如果不使用可控类型，需要加 lateinit 关键字： 12345class Hello&#123; private lateinit var name: String &#125; lateinit 是用来告诉编译器，name 这个变量后续会妥善处置的。 对于 final 的成员变量，Java 要求它们必须在构造方法或者构造块当中对他们进行初始化： 12345public class Hello&#123; private final String name = &quot;Peter&quot;; &#125; 也就是说，如果我要想定义一个可以延迟到一定实际再使用并初始化的 final 变量，这在 Java 中是做不到的。 Kotlin 有办法，使用 lazy 这个 delegate 即可： 12345678class Hello&#123; private val name by lazy&#123; NameProvider.getName() &#125;&#125; 只有使用到 name 这个属性的时候，lazy 后面的 Lambda 才会执行，name 的值才会真正计算出来。 11. 如何获得 class 的实例Java 当中： 12345678910public class Hello&#123; ...&#125;... Class&lt;?&gt; clazz = Hello.class; Hello hello = new Hello(); Class&lt;?&gt; clazz2 = hello.getClass(); 前面我们展示了两种获得 class 的途径，一种直接用类名，一种通过类实例。刚刚接触 Kotlin 的时候，获取 Java Class 的方法却是容易让人困惑。 同样效果的 Kotlin 代码看上去确实很奇怪，实际上 Hello::class 拿到的是 Kotlin 的 KClass，这个是 Kotlin 的类型，如果想要拿到 Java 的 Class 实例，那么就需要前面的办法了。 123class Helloval clazz = Hello::class.javaval hello = Hello() val clazz2 = hello.javaClass 12. 如何使使用单例模式Java 当中： （建议使用） 1234567891011121314151617181920212223/*** Created by yangc on 2017/6/9.* E-Mail:yangchaojiang@outlook.com* Deprecated: 定义一个私有的内部类，在第一次用这个嵌套类时，会创建一个实例。* 而类型为SingletonHolder的类，只有在Singleton.getInstance()中调用，* 由于私有的属性，他人无法使用SingleHolder，不* 调用Singleton.getInstance()就不会创建实例。* 优点：达到了lazy loading的效果，即按需创建实例*/ public class UserSingle &#123; static UserSingle getInstance() &#123;return Holder.userSingle;&#125;// 定义一个私有的构造方法private UserSingle() &#123;&#125; private static class Holder &#123;static final UserSingle userSingle = new UserSingle();&#125;&#125; Kotlin 中： 关键字 object 这个类属于单例 1234567891011121314class UserSingle private constructor() &#123; companion object &#123;@JvmStatic //java 访问fun getInstance(): UserSingle &#123;return Holder.instance&#125;&#125; private object Holder &#123;val instance = UserSingle()&#125; &#125; 单例模式 生对象更多的用途是用来创建一个单例类。 如果只是简单的写，直接用伴生对象返回一个 val 修饰的外部类对象就可以了， 但是更多的时候我们希望在类被调用的时候才去初始化他的对象。 以下代码将线程安全问题交给虚拟机在静态内部类加载时处理，是一种推荐的写 13. 如何使使用回调函数Java 当中： 123456789101112textView.setOnClickListener(new View.OnClickListener() &#123;@Overridepublic void onClick(View v) &#123; &#125;&#125;);textView.setOnLongClickListener(new View.OnLongClickListener() &#123;@Overridepublic boolean onLongClick(View v) &#123;return false;&#125;&#125;); Kotlin 中： 12345678910111213//不使用参数 返回voidbtnWrite.setOnClickListener &#123; fileWrite() &#125;//使用参数 返回voidbtnWrite.setOnClickListener &#123;view-&gt;fileWrite(c.getid()&#125;//使用参数 返回voidbtnWrite.setOnClickListener &#123;view-&gt;fileWrite(c.getid()true&#125; 在 kotlin 使用lambda 表达式，不用new 匿名内部类进行回调 {}括号中，直接添加代码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>博客日志 Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们站在世界的同一边]]></title>
    <url>%2F2017%2F06%2F22%2Flog03%2F</url>
    <content type="text"><![CDATA[养成一个良好的习惯就是每天跟新一篇博客妈的说不下去了❤ 懒癌晚期了今天差点断更了,哈哈一整天躺在床上一动未动. 外面下了一整天雨,心情无感.就是挺热的 北京的夏天就是闷热在家里好累啊. 又没投简历….没信心额…]]></content>
      <categories>
        <category>博客日志</category>
      </categories>
      <tags>
        <tag>博客日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给过去和未来的一封信]]></title>
    <url>%2F2017%2F06%2F21%2Flgo02%2F</url>
    <content type="text"><![CDATA[如果时光倒流回四年前不知道那是的我看了会不会流泪,&nbsp; 如果不行那多年以后我自己看了会不会笑出来呢?–致那个女孩❤ 我叫黄雷今年21岁,来自山西朔州木塔之乡 - 应县. 毕业于山西工程职业技术学院, 一所在冶金方面很”有名” 的大专院校,的计算机系 软件技术专业. 毕业季来临,随着传智播客培训的结束 我才恍然意识到我的学生生涯就此结束了 呵呵,真快,猝不及防. 对于未知的社会说实话没有做好准备,挺可怕的. 面对自己推掉的那5 6家面试机会才发现我又怂了就和3年前的这个时候一样我怂了,呵呵 我是个男人! 高二, 文理分科, 我们班级由于挨着实验班每天几个兄弟班级和实验班的”大佬”们飚纪检考核分. 每天红榜上前名永远是我们几个班. 每个月几百分的大数字,班主任每次看到后来我分到的那个班级每个月区区个位数的考核分屡次摇头叹息. 我带过的班级从来没有被扣过如此多的分.后来由于分班老人家不教书了,挺对不起他的虽然我没扣过几分. 分班后我进了教师阵容仅次于实验班的一个班级,老师个个是王者水平. 由于我本人比较淘,虽然我性格内向但是我和周围人玩的很high 啊 . 什么上语文课吹泡泡啊~ 疑似早恋啊(麻蛋都特么高二 了早恋你妹啊!! 这就是重点圈起来 &nbsp; 哈哈)~ 什么早读和同桌唱歌啦. 虽然都是什么小事,但是对于”打人不眨眼的”严厉新班主任来说已经很严重了.奇怪的是他重来没动过我可能是因为我生物成绩在任何情况下都名列前茅吧(他是生物老师) … 然并卵 就是因为分班的原因我遇到了那个在我心里挥之不去的姑娘 , 知道现在才发现我成熟的是有点晚哈 .都特么高二了才看上一个妹子…惭愧惭愧. 当时她就在我座位前面,也是分班来的,刚刚分了班级就放了暑假也没有太注意她,后开开学了渐渐注意到她,而且她比我大生日还是我生日的后一天.感觉这就是缘分吗?感觉她好美,呃~中邪了从此以后我便无法自拔. 可是没过多久我就发现她和隔壁班的那个男生走的特别近,一打听才知道她们在原来班级就挺好的但是她也不说那是她男朋友. 嘿`那我就不管了我就要追谁让你们不确定关系呢. 现在呢我只想说MDZZ. 可那是根本没有什么备胎啊什么的概念只是每天见到她就是很开心,所以我就经常逗她开心,她也没有拒绝我. 就这样我足足暗恋了他一年. 在高三的圣诞节我给她包了一个大大礼盒写了个狗屁不通的”情书” 向他表了白然后她又没有拒绝我. 妈的我居然天真的以为我恋爱了?? 哈哈天真, 就这样稀里糊涂加上搞不清关系还有我怂了. 很快 毕业了, 很明显我又二逼了 , 高考结束分数下来了很显然我落榜了…(意料之中 ) 然后没错她也落榜了,那几天不知道听谁说的说是什么网上填自愿挺麻烦的结果我就自己投了一个计算机专业,美滋滋的准备”追梦”了,我居然没和她交流一下心得结果她去了长春,我留在了山西.直到志愿填完我才意识到自己错过了什么. 整个大一我都很懊悔为什么我没有追随她,一起去长春,同时又庆幸自己学了计算机. 大一快结束的时候他说他找了男朋友了是数学系, 她说她不等了. 当时我整个人都是懵的, 可能是因为没有感情基础加上离得太远我真的无能为力. 作为一个内向的低情商,还不懂如何和一个女孩子交往直男从填下志愿的那一刻起仿佛就缘灭了,后来她又找了一个男孩子.我感觉他挺好的,她的动态我也一直在关注,她很幸福^.^ 有时候也祝福过,有时候也心痛过,说实话真的我是一个比较冷漠的人对一个女孩子我居然会心痛. 真的有时候真的痛. 有时候总是想和她说些什么却欲言又止,毕竟她有了新的生活 一个人飘在北京,没人陪伴,没有工作,站在昌平租的房子里看着窗外霓虹, 看着忙碌的人群,天上闪着信号灯的飞机,一时间百感交集,现在我21岁,现在的我一无所有. 2017.6.21 – 北京 new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: true, showlrc: 0, music: { title: "温柔乡", author: "陈雅森", url: "http://wp.hl262.top/Music/%E9%99%88%E9%9B%85%E6%A3%AE%20-%20%E6%B8%A9%E6%9F%94%E4%B9%A1.mp3", pic: "", } });]]></content>
      <categories>
        <category>博客日志</category>
      </categories>
      <tags>
        <tag>博客日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[养成一个好的习惯从每天更新一篇博客日志开始]]></title>
    <url>%2F2017%2F06%2F20%2Flog01%2F</url>
    <content type="text"><![CDATA[养成一个好的习惯从每天更新一篇博客日志开始我自己说的 对于一个程序员来说总结归纳的能力是很有用的, 所以从今往后每天更新自己的博客来发表发表心情提高自己的总结归纳能力.养成一个良好的习惯 2017.6.20 – 北京]]></content>
      <categories>
        <category>博客日志</category>
      </categories>
      <tags>
        <tag>博客日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub + Hexo搭建个人博客]]></title>
    <url>%2F2017%2F06%2F16%2FUseGitHub-HexoSetUpYouSelfBlog%2F</url>
    <content type="text"><![CDATA[生活是一面镜子。你对它笑，它就对你笑；你对它哭，它也对你哭。某名人-_-# 琢磨了一天终于一脸懵逼地用Hexo把新博客搭建起来了,在这里分享一下搭建的过程和遇到的一些问题接下来就是showTime 据本人了解Hexo原理是通过node.js把 Markdown格式的文本转化为静态页面,通过git上传到自己的GitHub pages项目上面 首先安装环境 1 .安装node.js (用于生成静态页面) 前往node.js官网下载对应pc的版本进行安装 2 .安装Git (用来push文件到GitHub) 同理上官网下载对应版本进行安装 3 .注册GitHub账号用来创建仓库 你懂得 接下来进行Hexo的安装 安装Hexo 在磁盘创建文件夹用来存放生成的博客文件 进入文件夹Shift + 鼠标右键 , 选择在此处打开cmd(此处省略若干cmd代码) 输入如下代码进行Hexo安装 1npm install -g hexo 成功后输入如下代码对Hexo进行初始化 1hexo init 初始化完成后博客文件就生成到创建的文件夹中Hexo安装完成 编译静态页面 1hexo g 启动本地服务进行调试,或者进入debug模式 123hexo shexo s --debug(调试模式) 如果没有报错并且访问http://localhost:4000成功则大功告成了 一半! GitHub创建仓库 注册并登陆GitHub后右上角点击加号选择 New repository 仓库名为:yourName.github.io (网上文章都说是必须填你的用户名) 点击创建,现在的仓库创建OK 接下来将生成的Hexo与GitHub仓库进行关联 在创建的文件夹(博客)根目录使用文本编辑器打开_config.yml配置文件 在文件最下面的部分修改为如下代码并保存 1234567deploy: type: git repo: https://github.com/你的用户名/你的用户名.github.io.git branch: master 然后执行命令： 1npm install hexo-deployer-git --save 然后输入配置命令 1hexo d 将博客推到仓库中 第一次会弹出GitHub登陆 最后访问 你的用户名.github.io访问博客 每次有博客更新使用 1hexo d -g 编译并上传 Hexo的基本使用 创建新的文章 12hexo new &quot;postName&quot;#文章名不要用中文不然会无法提交 创建新页面 12hexo new page &quot;PageName&quot;#创建后会在根目录/source/目录下出现所创建的页面的文件夹里面是一个md文档,像编辑Html编辑就可以 最后 本文参考简书作者作 潘柏信 及CSDNgdutxiaoxu的两篇文章]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android资料库]]></title>
    <url>%2F2017%2F06%2F16%2FDocLib%2F</url>
    <content type="text"><![CDATA[基础知识 Java代码中的面向对象 JDK 1.8 Lambda表达式 组件 Activity Activity生命周期及启动模式介绍 Activity之间的值传递 Activity的加载模式 控件使用 FragmentTabHost(相当于ViewPager的TabLayout) DrawerLayout 安卓自带侧拉菜单 进阶知识 消息机制 Handler AsyncTask异步任务 TCP/IP - 阿里中间件技术博客 Android中的第三方图片加载库 设计模式 单例模式 单例的七种写法 事件分发机制详解 事件分发(郭霖) Android动画机制详解(徐宜生) Android5.0 &amp; 6.0 新增控件 - 来自CSDN Android中样式类Span操作富文本 第三方SDK及开源框架 开源框架 网络框架 Retrofit 图片加载框架 进程间通信 数据库框架 MM]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>知识库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用子域名在虚拟主机中]]></title>
    <url>%2F2017%2F06%2F15%2FWordpressChildWebSite%2F</url>
    <content type="text"><![CDATA[使用的产品:本文使用的是阿里云的Web 弹性托管 暂时没有测试数据库的问题 实现步骤: 在已备案的域名下添加子域名解析 在弹性微博托管控制台添加域名绑定 使用FTP工具在网站根目录创名为test的建子文件夹,并上传网站文件到目录 创建文本文件内容如下 12345RewriteEngine OnRewriteCond %&#123;HTTP_HOST&#125; ^(www.)?test.hl262.top$RewriteRule ^(/)?$ test [L] ​ 上传文件到网站根目录并改名为.htaccess 访问子域名test.hl262.top成功如下图]]></content>
      <tags>
        <tag>子域名</tag>
      </tags>
  </entry>
</search>